# -*- coding: utf-8 -*-
"""XOR Learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ba_9yyGwgTM4DvfB63EwO9m8C8zqI0Q_
"""

import numpy as np
import torch
import torch.nn as nn

device = 'cuda' if torch.cuda.is_available() else 'cpu'

torch.manual_seed(777)
if device == 'cuda':
    torch.cuda.manual_seed_all(777)

"""# Data setting"""

input = [[0,0], 
         [0,1], 
         [1,0], 
         [1,1]]
         
answer = [[0],[1],[1],[0]]

X = torch.FloatTensor(input).to(device)
Y = torch.FloatTensor(answer).to(device)

"""# network modeling"""

network = nn.Sequential(
    nn.Linear(2, 7, bias=True),  # input : 2, hidden1 : 7
    nn.Sigmoid(),
    nn.Linear(7, 7, bias=True),  # hidden1: 7, hidden2: 7
    nn.Sigmoid(),
    nn.Linear(7, 7, bias=True),  # hidden1: 7, hidden2: 7
    nn.Sigmoid(),
    nn.Linear(7, 1, bias=True), # hidden2: 7, output: 1
    nn.Sigmoid()
).to(device)

criteria =  torch.nn.BCELoss().to(device)
optimizer =  torch.optim.SGD(network.parameters(), lr=1)

"""# Training"""

for epoch in range(10001):
  optimizer.zero_grad()                   # gradient initialize

  predict = network(X)                    # forward propagation

  cost = criteria(predict, Y)             # loss calculate
  cost.backward()                         # back propagation
  optimizer.step()                        # update the weight parameter

  if epoch % 1000 == 0:
    print(epoch, ":", cost.item())        # print loss's scalar value

"""# Prediction"""

with torch.no_grad():
  predict = network(X)
  result = (predict > 0.5).float()
  accuracy = (result == Y).float().mean()
  print('모델의 예측값(Predicted): \n', result.detach().cpu().numpy())
  print('실제값(Y): \n', Y.cpu().numpy())
  print('정확도(Accuracy): ', accuracy.item())